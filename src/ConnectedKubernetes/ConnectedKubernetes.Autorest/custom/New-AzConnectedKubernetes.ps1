
# ----------------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
# is regenerated.
# ----------------------------------------------------------------------------------

<#
.Synopsis
API to register a new Kubernetes cluster and create a tracked resource in Azure Resource Manager (ARM).
.Description
API to register a new Kubernetes cluster and create a tracked resource in Azure Resource Manager (ARM).
.Example
New-AzConnectedKubernetes -ClusterName azps_test_cluster -ResourceGroupName azps_test_group -Location eastus
.Example
New-AzConnectedKubernetes -ClusterName azps_test_cluster1 -ResourceGroupName azps_test_group -Location eastus -KubeConfig $HOME\.kube\config -KubeContext azps_aks_t01

.Outputs
Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.IConnectedCluster
.Link
https://learn.microsoft.com/powershell/module/az.connectedkubernetes/new-azconnectedkubernetes
#>

[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseSingularNouns', '',
    Justification='Helm values is a recognised term', Scope='Function', Target='Get-HelmValues')]
[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseSingularNouns', '',
    Justification='MetaData is a recognised term', Scope='Function', Target='Get-AzCloudMetaData')]
[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseSingularNouns', '',
    Justification='Willl retry multiple times', Scope='Function', Target='Invoke-RestMethodWithUriParameters')]
[System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSUseSingularNouns', '',
    Justification='Kubernetes is a recognised term', Scope='Function', Target='New-AzConnectedKubernetes')]
param()

function New-AzConnectedKubernetes {
    [OutputType([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.IConnectedCluster])]
    [CmdletBinding(DefaultParameterSetName='CreateExpanded', PositionalBinding=$false, SupportsShouldProcess, ConfirmImpact='Medium')]
    [System.Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingConvertToSecureStringWithPlainText', '',
        Justification='Code published before this issue was identified')]
    param(
        [Parameter(Mandatory)]
        [Alias('Name')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # The name of the Kubernetes cluster on which get is called.
        ${ClusterName},

        [Parameter(Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # The name of the resource group.
        # The name is case insensitive.
        ${ResourceGroupName},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Runtime.DefaultInfo(Script='(Get-AzContext).Subscription.Id')]
        [System.String]
        # The ID of the target subscription.
        ${SubscriptionId},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.Uri]
        # The http URI of the proxy server for the kubernetes cluster to use
        ${HttpProxy},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.Uri]
        # The https URI of the proxy server for the kubernetes cluster to use
        ${HttpsProxy},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # The comma-separated list of hostnames that should be excluded from the proxy server for the kubernetes cluster to use
        ${NoProxy},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # The path to the certificate file for proxy or custom Certificate Authority.
        ${ProxyCert},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [ValidateRange(0,3600)]
        [Int]
        # The time required (in seconds) for the arc-agent pods to be installed on the kubernetes cluster.
        ${OnboardingTimeout} = 600,

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.Management.Automation.SwitchParameter]
        # Flag to disable auto upgrade of arc agents.
        ${DisableAutoUpgrade},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Path')]
        [System.String]
        # Override the default container log path to enable fluent-bit logging.
        ${ContainerLogPath},

        [Parameter(HelpMessage="Path to the kube config file")]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # Path to the kube config file
        ${KubeConfig},

        [Parameter(HelpMessage="Kubconfig context from current machine")]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # Kubconfig context from current machine
        ${KubeContext},

        [Parameter(Mandatory)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The geo-location where the resource lives
        ${Location},

        [Parameter()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.AzureHybridBenefit])]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.AzureHybridBenefit]
        # Indicates whether Azure Hybrid Benefit is opted in
        ${AzureHybridBenefit},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The Kubernetes distribution running on this connected cluster.
        ${Distribution},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The Kubernetes distribution version on this connected cluster.
        ${DistributionVersion},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The infrastructure on which the Kubernetes cluster represented by this connected cluster is running on.
        ${Infrastructure},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # The resource id of the private link scope this connected cluster is assigned to, if any.
        ${PrivateLinkScopeResourceId},

        [Parameter()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.PrivateLinkState])]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.PrivateLinkState]
        # Property which describes the state of private link on a connected cluster resource.
        ${PrivateLinkState},

        [Parameter()]
        [ArgumentCompleter([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.ProvisioningState])]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.ProvisioningState]
        # Provisioning state of the connected cluster resource.
        ${ProvisioningState},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Runtime.Info(PossibleTypes=([Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20.ITrackedResourceTags]))]
        [System.Collections.Hashtable]
        # Resource tags.
        ${Tag},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Body')]
        [System.String]
        # OID of 'custom-locations' app.
        ${CustomLocationsOid},

        [Parameter()]
        [System.Management.Automation.SwitchParameter]
        # Accept EULA of ConnectedKubernetes, legal term will pop up without this parameter provided
        ${AcceptEULA},

        [Parameter()]
        [Alias('AzureRMContext', 'AzureCredential')]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Azure')]
        [System.Management.Automation.PSObject]
        # The credentials, account, tenant, and subscription used for communication with Azure.
        ${DefaultProfile},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command as a job
        ${AsJob},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Wait for .NET debugger to attach
        ${Break},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be appended to the front of the pipeline
        ${HttpPipelineAppend},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Runtime.SendAsyncStep[]]
        # SendAsync Pipeline Steps to be prepended to the front of the pipeline
        ${HttpPipelinePrepend},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Run the command asynchronously
        ${NoWait},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Uri]
        # The URI of the proxy server for host os to use
        ${Proxy},

        [Parameter(DontShow)]
        [ValidateNotNull()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.PSCredential]
        # The credential of the proxy server for host os to use
        ${ProxyCredential},

        [Parameter(DontShow)]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Management.Automation.SwitchParameter]
        # Use the default credentials for the proxy
        ${ProxyUseDefaultCredentials},

        [Parameter()]
        [ValidateSet("gateway", "direct")]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.String]
        # Azure connections are either direct or via an Arc Gateway
        ${ConnectionType},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Collections.Hashtable]
        # Arc Agentry System Configuration
        ${ArcAgentrySettings},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.Collections.Hashtable]
        # Arc Agentry System Protected Configuration
        ${ArcAgentryProtectedSettings},

        [Parameter()]
        [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Category('Runtime')]
        [System.String]
        # Arc Gateway resource Id
        ${GatewayResoureceId}
    )

    process {
        . "$PSScriptRoot/helpers/HelmHelper.ps1"
        if($AzureHybridBenefit){
            if(!$AcceptEULA){
                $legalTermPath = Join-Path $PSScriptRoot -ChildPath "LegalTerm.txt"
                try {
                    $legalTerm = (Get-Content -Path $legalTermPath) -join "`r`n"
                } catch {
                    Write-Error "Get legal term failed."
                    throw
                }
                $confirmation = Read-Host $legalTerm"`n[Y] Yes  [N] No  (default is `"N`")"
                if($confirmation -ine "Y"){
                    Return
                }
            }
        }
        $null = $PSBoundParameters.Remove('AcceptEULA')


        if ($PSBoundParameters:KubeConfig) {
            $Null = $PSBoundParameters.Remove('KubeConfig')
        } elseif (Test-Path Env:KUBECONFIG) {
            $KubeConfig = Get-ChildItem -Path Env:KUBECONFIG
        } elseif (Test-Path Env:Home) {
            $KubeConfig = Join-Path -Path $Env:Home -ChildPath '.kube' | Join-Path -ChildPath 'config'
        } else {
            $KubeConfig = Join-Path -Path $Home -ChildPath '.kube' | Join-Path -ChildPath 'config'
        }
        if (-not (Test-Path $KubeConfig)) {
            Write-Error 'Cannot find the kube-config. Please make sure that you have the kube-config on your machine.'
            return
        }
        if ($PSBoundParameters:KubeContext) {
            $Null = $PSBoundParameters.Remove('KubeContext')
        }
        if (($null -eq $KubeContext) -or ($KubeContext -eq '')) {
            $KubeContext = kubectl config current-context
        }

        if ($PSBoundParameters:ConnectionType) {
            if ($ConnectionType.Equals("direct")) {
                if ($PSBoundParameters:GatewayResourceId) {
                    Write-Error 'GatewayResourceId should not be provided when ConnectionType is "direct".'
                    return
                }
            }
        }

        $CommonPSBoundParameters = @{}
        if ($PSBoundParameters:HttpPipelineAppend) {
            $CommonPSBoundParameters['HttpPipelineAppend'] = $HttpPipelineAppend
        }
        if ($PSBoundParameters:HttpPipelinePrepend) {
            $CommonPSBoundParameters['HttpPipelinePrepend'] = $HttpPipelinePrepend
        }
        if ($PSBoundParameters:SubscriptionId) {
            $CommonPSBoundParameters['SubscriptionId'] = $SubscriptionId
        }
        if ($PSBoundParametersPrivateLinkState -and ($null -ne $CustomLocationsOid) -and ($CustomLocationsOid -ne '')) {
            Write-Warning "The features 'cluster-connect' and 'custom-locations' cannot be enabled for a private link enabled connected cluster."
            $CustomLocationsOid = $null
        }
        if ($PSBoundParametersCustomLocationsOid) {
            $Null = $PSBoundParameters.Remove('CustomLocationsOid')
        }
        $IdentityType = [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Support.ResourceIdentityType]::SystemAssigned
        $PSBoundParameters.Add('IdentityType', $IdentityType)

        #Region check helm install
        try {
            Set-HelmClientLocation
            $HelmVersion = helm version --template='{{.Version}}' --kubeconfig $KubeConfig
            if ($HelmVersion.Contains("v2")) {
                Write-Error "Helm version 3+ is required (not ${HelmVersion}). Learn more at https://aka.ms/arc/k8s/onboarding-helm-install"
                return
            }
            $HelmVersion = helm version --short --kubeconfig $KubeConfig

            # Compare the helm version to 3.8 in a symantic versioning valid way
            # Strip the leading "v" from the helm version and discard any metadata
            $HelmVersion = $HelmVersion.Substring(1)
            $HelmVersion = $HelmVersion.Split('+')[0]
            $helmV380 = [System.Version]::Parse("3.8.0")
            $helmThisVersion= [System.Version]::Parse($HelmVersion)
            if ($helmThisVersion -lt $helmV380) {
                Write-Error "Helm version of at least 3.8 is required for latest OCI handling."
                Return
            }
        } catch {
            throw "Failed to install Helm version 3+ ($_). Learn more at https://aka.ms/arc/k8s/onboarding-helm-install"
        }
        #EndRegion
        $helmClientLocation = 'helm'

        #Region get release namespace
        $ReleaseInstallNamespace = Get-ReleaseInstallNamespace
        $ReleaseNamespace = $null
        try {
            # !!PDS: Seems like this showing "Error: Release: Not found" is not an error but a warning that implies there just is not a release.  Can we quench this?
            $ReleaseNamespace = (helm status azure-arc -o json --kubeconfig $KubeConfig --kube-context $KubeContext -n $ReleaseInstallNamespace 2> $null | ConvertFrom-Json).namespace
        } catch {
            Write-Error "Fail to find the namespace for azure-arc."
        }
        #Endregion

        if ($null -ne $ReleaseNamespace) {
            # !!PDS: Is this a bug?  "--namespace $ReleaseNamespace" surely?
            $Configmap = kubectl get configmap --namespace azure-arc azure-clusterconfig -o json --kubeconfig $KubeConfig | ConvertFrom-Json
            $ConfigmapRgName = $Configmap.data.AZURE_RESOURCE_GROUP
            $ConfigmapClusterName = $Configmap.data.AZURE_RESOURCE_NAME
            try {
                $ExistConnectedKubernetes = Get-AzConnectedKubernetes -ResourceGroupName $ConfigmapRgName -ClusterName $ConfigmapClusterName @CommonPSBoundParameters

                if (($ResourceGroupName -eq $ConfigmapRgName) -and ($ClusterName -eq $ConfigmapClusterName)) {
                    # This performs a re-PUT of an existing connected cluster which should really be done using
                    # a Set-AzConnectedKubernetes cmdlet!
                    $PSBoundParameters.Add('AgentPublicKeyCertificate', $ExistConnectedKubernetes.AgentPublicKeyCertificate)
                    return Az.ConnectedKubernetes.internal\New-AzConnectedKubernetes @PSBoundParameters
                } else {
                    # We have a cluster with the same Kubernetes settings but already associated via a different RG - error!
                    Write-Error "The kubernetes cluster you are trying to onboard is already onboarded to the resource group '${ConfigmapRgName}' with resource name '${ConfigmapClusterName}'."
                }
                return
            } catch {
                # This is attempting to delete Azure Arc resources that are orphaned.
                helm delete azure-arc --namespace $ReleaseNamespace --kubeconfig $KubeConfig --kube-context $KubeContext
            }
        }

        if ((Test-Path Env:HELMREPONAME) -and (Test-Path Env:HELMREPOURL)) {
            $HelmRepoName = Get-ChildItem -Path Env:HELMREPONAME
            $HelmRepoUrl = Get-ChildItem -Path Env:HELMREPOURL
            helm repo add $HelmRepoName $HelmRepoUrl --kubeconfig $KubeConfig --kube-context $KubeContext
        }

        $resources = Get-Module Az.Resources -ListAvailable
        if ($null -eq $resources) {
            Write-Error "Missing required module(s): Az.Resources. Please run 'Install-Module Az.Resources -Repository PSGallery' to install Az.Resources."
            return
        }
        if (Test-Path Env:HELMREGISTRY) {
            $RegistryPath = Get-ChildItem -Path Env:HELMREGISTRY
        } else {
            $ReleaseTrain = ''
            if ((Test-Path Env:RELEASETRAIN) -and (Test-Path Env:RELEASETRAIN)) {
                $ReleaseTrain = Get-ChildItem -Path Env:RELEASETRAIN
            } else {
                $ReleaseTrain = 'stable'
            }
            $AzLocation = Get-AzLocation | Where-Object { ($_.DisplayName -ieq $Location) -or ($_.Location -ieq $Location)}
            $Region = $AzLocation.Location
            if ($null -eq $Region) {
                Write-Error "Invalid location: $Location"
                return
            } else {
                $Location = $Region
            }
            $ChartLocationUrl = "https://${Location}.dp.kubernetesconfiguration.azure.com/azure-arc-k8sagents/GetLatestHelmPackagePath?api-version=2019-11-01-preview&releaseTrain=${ReleaseTrain}"

            $Uri = [System.Uri]::New($ChartLocationUrl)
            $Account = [Microsoft.Azure.Commands.Common.Authentication.Abstractions.AzureRmProfileProvider]::Instance.Profile.DefaultContext.Account
            $Env = [Microsoft.Azure.Commands.Common.Authentication.Abstractions.AzureEnvironment]::PublicEnvironments[[Microsoft.Azure.Commands.Common.Authentication.Abstractions.EnvironmentName]::AzureCloud]
            $TenantId = [Microsoft.Azure.Commands.Common.Authentication.Abstractions.AzureRmProfileProvider]::Instance.Profile.DefaultContext.Tenant.Id
            $PromptBehavior = [Microsoft.Azure.Commands.Common.Authentication.ShowDialog]::Never
            $Token = [Microsoft.Azure.Commands.Common.Authentication.AzureSession]::Instance.AuthenticationFactory.Authenticate($account, $env, $tenantId, $null, $promptBehavior, $null)
            $AccessToken = $Token.AccessToken

            $HeaderParameter = @{
                "Authorization" = "Bearer $AccessToken"
            }

            $Response = Invoke-WebRequest -Uri $Uri -Headers $HeaderParameter -Method Post -UseBasicParsing
            if ($Response.StatusCode -eq 200) {
                $RegistryPath = ($Response.Content | ConvertFrom-Json).repositoryPath
            } else {
                Write-Error "Error while fetching helm chart registry path: ${$Response.RawContent}"
                return
            }
        }
        Set-Item -Path Env:HELM_EXPERIMENTAL_OCI -Value 1

        # Region create RSA keys
        $RSA = [System.Security.Cryptography.RSA]::Create(4096)
        if ($PSVersionTable.PSVersion.Major -eq 5) {
            try {
                . "$PSScriptRoot/helpers/RSAHelper.ps1"
                $AgentPublicKey = ExportRSAPublicKeyBase64($RSA)
                $AgentPrivateKey = ExportRSAPrivateKeyBase64($RSA)
                $AgentPrivateKey = "-----BEGIN RSA PRIVATE KEY-----`n" + $AgentPrivateKey + "`n-----END RSA PRIVATE KEY-----"
            } catch {
                throw "Unable to generate RSA keys"
            }
        } else {
            $AgentPublicKey = [System.Convert]::ToBase64String($RSA.ExportRSAPublicKey())
            $AgentPrivateKey = "-----BEGIN RSA PRIVATE KEY-----`n" + [System.Convert]::ToBase64String($RSA.ExportRSAPrivateKey()) + "`n-----END RSA PRIVATE KEY-----"
        }
        #Endregion

        # $HelmChartPath = Join-Path -Path $ChartExportPath -ChildPath 'azure-arc-k8sagents'
        # if (Test-Path Env:HELMCHART) {
        #     $ChartPath = Get-ChildItem -Path Env:HELMCHART
        # } else {
        #     $ChartPath = $HelmChartPath
        # }

        #Region helm options
        # !!PDS: The az cli also sets the "proxy" fields in the settings and
        #        passes these to Azure.  Do we need to do this as well?
        $options = ""
        $proxyEnableState = $false
        if (-not ([string]::IsNullOrEmpty($HttpProxy))) {
            $HttpProxyStr = $HttpProxy.ToString()
            $HttpProxyStr = $HttpProxyStr -replace ',','\,'
            $HttpProxyStr = $HttpProxyStr -replace '/','\/'
            $options += " --set global.httpProxy=$HttpProxyStr"
            $proxyEnableState = $true
            # Note how we are removing k8s parameters from the list of parameters
            # to pass to the internal (creates ARM object) command.
            $Null = $PSBoundParameters.Remove('HttpProxy')
        }
        if (-not ([string]::IsNullOrEmpty($HttpsProxy))) {
            $HttpsProxyStr = $HttpsProxy.ToString()
            $HttpsProxyStr = $HttpsProxyStr -replace ',','\,'
            $HttpsProxyStr = $HttpsProxyStr -replace '/','\/'
            $options += " --set global.httpsProxy=$HttpsProxyStr"
            $proxyEnableState = $true
            $Null = $PSBoundParameters.Remove('HttpsProxy')
        }
        if (-not ([string]::IsNullOrEmpty($NoProxy))) {
            $NoProxy = $NoProxy -replace ',','\,'
            $NoProxy = $NoProxy -replace '/','\/'
            $options += " --set global.noProxy=$NoProxy"
            $proxyEnableState = $true
            $Null = $PSBoundParameters.Remove('NoProxy')
        }
        if ($proxyEnableState) {
            $options += " --set global.isProxyEnabled=true"
        }
        try {
            if ((-not ([string]::IsNullOrEmpty($ProxyCert))) -and (Test-Path $ProxyCert)) {
                $options += " --set-file global.proxyCert=$ProxyCert"
                $options += " --set global.isCustomCert=true"
            }
        } catch {
            throw "Unable to find ProxyCert from file path"
        }
        if ($DisableAutoUpgrade) {
            $options += " --set systemDefaultValues.azureArcAgents.autoUpdate=false"
            $Null = $PSBoundParameters.Remove('DisableAutoUpgrade')
        }
        if (-not ([string]::IsNullOrEmpty($ContainerLogPath))) {
            $options += " --set systemDefaultValues.fluent-bit.containerLogPath=$ContainerLogPath"
            $Null = $PSBoundParameters.Remove('ContainerLogPath')
        }
        if (-not ([string]::IsNullOrEmpty($KubeConfig))) {
            $options += " --kubeconfig $KubeConfig"
        }
        if (-not ([string]::IsNullOrEmpty($KubeContext))) {
            $options += " --kube-context $KubeContext"
        }
        if (-not ([string]::IsNullOrEmpty($CustomLocationsOid))) {
            $options += " --set systemDefaultValues.customLocations.oid=$CustomLocationsOid"
            $options += " --set systemDefaultValues.customLocations.enabled=true"
        }
        if (!$NoWait) {
            $options += " --wait --timeout $OnboardingTimeout"
            $options += "s"
        }
        #Endregion

        if ($PSBoundParameters.ContainsKey('OnboardingTimeout')) {
            $PSBoundParameters.Remove('OnboardingTimeout')
        }
        if ((-not ([string]::IsNullOrEmpty($Proxy))) -and (-not $PSBoundParameters.ContainsKey('ProxyCredential'))) {
            if (-not ([string]::IsNullOrEmpty($Proxy.UserInfo))) {
                try{
                    $userInfo = $Proxy.UserInfo -Split ':'
                    $pass = ConvertTo-SecureString $userInfo[1] -AsPlainText -Force
                    $ProxyCredential = New-Object System.Management.Automation.PSCredential ($userInfo[0] , $pass)
                    $PSBoundParameters.Add('ProxyCredential', $ProxyCredential)
                } catch {
                    throw "Please set ProxyCredential or provide username and password in the Proxy parameter"
                }
            } else {
                Write-Warning "If the proxy is a private proxy, pass ProxyCredential parameter or provide username and password in the Proxy parameter"
            }
        }

        # Process the Arc agentry settings and protected settings
        # Create any empty array of IArcAgentryConfigurations.
        # shortened name to avoid class with type name.
        $arcAgentryConfigs = @(
        )

        # !!PDS: The name "Setting" below is SINGULAR but in the Swagger it is PLURAL - why is this?
        if ($ArcAgentrySettings) {
            foreach ($key in $ArcAgentrySettings.Keys) {
                $ArcAgentryConfiguration = [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.ArcAgentryConfigurations]@{
                    Feature = $key
                    Setting = $ArcAgentrySettings[$key]
                }
                if ($ArcAgentryProtectedSettings -and $ArcAgentryProtectedSettings[$key]) {
                    $ArcAgentryConfiguration.ProtectedSetting = $ArcAgentryProtectedSettings[$key]

                    # Remove this key from ArcAgentryProtectedSettings.
                    $Null = $ArcAgentryProtectedSettings.Remove($key)
                }
                $arcAgentryConfigs += $ArcAgentryConfiguration
            }
            $PSBoundParameters.Remove('ArcAgentrySettings')
        }

        # Add the remaining (protected only) settings.
        if ($ArcAgentryProtectedSettings) {
            foreach ($key in $ArcAgentryProtectedSettings.Keys) {
                $ArcAgentryConfiguration = [Microsoft.Azure.PowerShell.Cmdlets.ConnectedKubernetes.Models.Api20240701Preview.ArcAgentryConfigurations]@{
                    Feature = $key
                    ProtectedSetting = $ArcAgentryprotectedSettings[$key]
                }
                $argAgentryConfigs += $ArcAgentryConfiguration
            }
            $PSBoundParameters.Remove('ArcAgentryProtectedSettings')
        }

        Write-Error "ArcAgentryConfiguration: $arcAgentryConfigs"
        $PSBoundParameters.Add('ArcAgentryConfiguration', $arcAgentryConfigs)

        # A lot of what follows relies on knowing the cloud we are using and the
        # various endpoints so get that information now.
        $cloudMetadata = Get-AzCloudMetadata

        # Perform DP health check

        # !!PDS: There is no dogfood so not required?
        # $valuesFile = Get-ValuesFile
        $configDpinfo = Get-ConfigDPEndpoint -location $Location -Cloud $cloudMetadata
        $configDPEndpoint = $configDpInfo.configDPEndpoint
        $adResourceId = $configDpInfo.adResourceId
        Invoke-HealthCheckDP -configDPEndpoint $configDPEndpoint -Resource $adResourceId

        # This call does the "pure ARM" update of the ARM objects.
        Write-Debug "Writing Connected Kubernetes ARM objects."
        $PSBoundParameters.Add('AgentPublicKeyCertificate', $AgentPublicKey)
        $Response = Az.ConnectedKubernetes.internal\New-AzConnectedKubernetes @PSBoundParameters

        # Retrieving Helm chart OCI (Open Container Initiative) Artifact location
        Write-Debug "Retrieving Helm chart OCI (Open Container Initiative) Artifact location."
        $helmValuesDp = Get-HelmValues -configDPEndpoint $configDPEndpoint -releaseTrain $ReleaseTrain -requestBody $Response
        Write-Debug "OCI Artifact location: ${helmValuesDp.repositoryPath}."

        # Allow a custom OCI registry to be set via environment variables.
        # !!PDS: Where are these variables documented?  Should they be?
        #
        # AZURE_ACCESS_TOKEN
        # HELMCHART
        # HELMCHART
        # HELMREGISTRY
        # HELMVALUESPATH
        # RELEASETRAIN
        # USERPROFILE
        #
        $registryPath = if ($env:HELMREGISTRY) { $env:HELMREGISTRY } else { $helmValuesDp.repositoryPath }
        Write-Debug "RegistryPath: ${registryPath}."

        $helmContentValues = $helmValuesDp["helmValuesContent"]
        Write-Debug "Helm values: ${helmContentValues}."

        # !!PDS: Is there any telemetry in Powershell cmdlets?
        # # Get azure-arc agent version for telemetry
        # azure_arc_agent_version = registry_path.split(":")[1]
        # telemetry.add_extension_event(
        #     "connectedk8s",
        #     {"Context.Default.AzureCLI.AgentVersion": azure_arc_agent_version},
        # )

        # Get helm chart path (within the OCI registry).
        $chartPath = Get-ChartPath -registryPath $registryPath -kubeConfig $KubeConfig -kubeContext $KubeContext -helmClientLocation $HelmClientLocation
        if (Test-Path Env:HELMCHART) {
            $ChartPath = Get-ChildItem -Path Env:HELMCHART
        }

        Write-Debug "Helm chart path: ${chartPath}."

        # Substitute any protected helm values as the value for that will be null
        # !!PDS: Where are the unprotected values?
        $protectedHelmValues = @{}
        foreach ($item in $protectedHelmValues.GetEnumerator()) {
            $helmContentValues[$item.Key] = $item.Value
        }

        # !!PDS Aren't we supposed to read the helm config from the Cluster Config DP?
        # !!PDS: I think we might have done above, but why are we setting many options?
        $TenantId = [Microsoft.Azure.Commands.Common.Authentication.Abstractions.AzureRmProfileProvider]::Instance.Profile.DefaultContext.Tenant.Id
        try {
            helm upgrade `
            --debug `
            --install azure-arc `
            $ChartPath `
            --namespace $ReleaseInstallNamespace `
            --create-namespace `
            --set global.subscriptionId=$SubscriptionId `
            --set global.resourceGroupName=$ResourceGroupName `
            --set global.resourceName=$ClusterName `
            --set global.tenantId=$TenantId `
            --set global.location=$Location `
            --set global.onboardingPrivateKey=$AgentPrivateKey `
            --set systemDefaultValues.spnOnboarding=false `
            --set global.azureEnvironment=AZUREPUBLICCLOUD `
            --set systemDefaultValues.clusterconnect-agent.enabled=true `
            --set global.kubernetesDistro=$Distribution `
            --set global.kubernetesInfra=$Infrastructure (-split $options)

        } catch {
            throw "Unable to install helm chart at $ChartPath"
        }
        Return $Response
    }
}

function Invoke-HealthCheckDP {
    param (
        [string]$configDPEndpoint
    )

    Write-Debug "Perform DP health check"
    # Setting uri
    $apiVersion = "2024-07-01-preview"
    $chartLocationUrlSegment = "azure-arc-k8sagents/healthCheck?api-version=$apiVersion"
    $chartLocationUrl = "$configDPEndpoint/$chartLocationUrlSegment"
    $uriParameters = @{}
    $headers = @{}
    # Check if key AZURE_ACCESS_TOKEN exists in environment variables
    if ($env:AZURE_ACCESS_TOKEN) {
        $headers = @{"Authorization"="Bearer $($env['AZURE_ACCESS_TOKEN'])"}
    }

    # Sending request with retries
    # $r = Invoke-RestMethodWithRetries -method 'post' -url $chartLocationUrl -headers $headers -faultType $consts.Get_HelmRegistery_Path_Fault_Type -summary 'Error while performing DP health check' -uriParameters $uriParameters -resource $resource
    Invoke-RestMethodWithUriParameters -Method 'post' -Uri $chartLocationUrl -Headers $headers -UriParameters $uriParameters -MaximumRetryCount 5 -RetryIntervalSec 3 -StatusCodeVariable statusCode
    if ($statusCode -eq 200) {
        Write-Output "Health check for DP is successful."
        return $true
    }
    else {
        throw "Error while performing DP health check, StatusCode: ${statusCode}"
    }
}

function Invoke-RestMethodWithUriParameters {
    param (
        [String]$method,
        [String]$uri,
        [Hashtable]$headers,
        [Hashtable]$uriParameters,
        [String]$requestBody,
        [Int]$maximumRetryCount,
        [Int]$retryIntervalSec,
        [String]$statusCodeVariable
    )

    # Add URI parameters to end of URL if there are any.
    $uriParametersArray = @()
    foreach ($Key in $hash.Keys) {
        $uriParametersArray.Add("$($Key)=$($UriParameters[$Key])")
        $uriParametersString = $uriParametersArray -join '&'
        $uri = "$url?$uriParametersString"
    }

    # if ($uriParameters.count -gt 0) {
    #     # Create an array by joining hash index and value using '=' and join them using '&'
    #     $uriParametersArray = $uriParameters.GetEnumerator() | ForEach-Object { "$($_.Key)=$($_.Value)" } | ForEach-Object { $_ -join '=' } | ForEach-Object { $_ -join '&' }
    # }
    Write-Debug "Issue REST request to ${uri} with method ${method} and headers ${headers} and body ${requestBody}"
    $rsp = Invoke-RestMethod -Method $method -Uri $uri -Headers $headers -Body $requestBody -ContentType "application/json"  -MaximumRetryCount $maximumRetryCount -RetryIntervalSec $retryintervalSec -StatusCodeVariable statusCode
    Set-Variable -Name "${statusCodeVariable}" -Value $statusCode -Scope script
    if ($statusCode -ne 200) {
        throw "health check failed, StatusCode: ${statusCode}."
    }
    return $rsp
}

function Get-SubscriptionIdFromResourceId {
    param (
        [parameter(mandatory=$true)]
        [string]$resourceId
    )

    # Split the URL based on "/"
    $resIdParts = $resourceId -split '/'

    # Find the index of "subscriptions" in $urlParts
    $subscriptionIndex = $resIdParts.IndexOf('subscriptions')

    # If "subscriptions" is not found, return $null
    if ($subscriptionIndex -eq -1) {
        return $null
    }

    # Return the value after "subscriptions"
    return $resIdParts[$subscriptionIndex + 1]
}

function Get-ConfigDPEndpoint {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Location,
        [Parameter(Mandatory=$true)]
        [PSCustomObject]$cloudMetadata
    )

    $ReleaseTrain = $null
    $ConfigDpEndpoint = $null

    # !!PDS: No dogfood!
    # # Read and validate the helm values file for Dogfood.
    # if ($Cmd.cli_ctx.cloud.endpoints.resource_manager -eq $consts.Dogfood_RMEndpoint) {
    #     # !!PDS Need to write this.
    #     $result = Validate-EnvFileDogfood -ValuesFile $ValuesFile
    #     $ConfigDpEndpoint = $result.ConfigDpEndpoint
    #     $ReleaseTrain = $result.ReleaseTrain
    # }

    # Get the values or endpoints required for retrieving the Helm registry URL.
    if ($cloudMetadata.dataplaneEndpoints -and $cloudMetadata.dataplaneEndpoints.arcConfigEndpoint) {
        $ConfigDpEndpoint = $armMetadata.dataplaneEndpoints.arcConfigEndpoint
    }
    else {
        Write-Debug "'arcConfigEndpoint' doesn't exist under 'dataplaneEndpoints' in the ARM metadata."
    }

    # Get the default config dataplane endpoint.
    if (-not $ConfigDpEndpoint) {
        $ConfigDpEndpoint = Get-DefaultConfigDPEndpoint -Location $Location -CloudMetadata $cloudMetadata
    }
    $ADResourceId = Get-ADResourceId -CloudMetadata $cloudMetadata

    return @{ ConfigDpEndpoint = $ConfigDpEndpoint; ReleaseTrain = $ReleaseTrain; ADResourceId = $ADResourceId }
}

function Get-DefaultConfigDpEndpoint {
    param (
        [Parameter(Mandatory=$true)]
        [string]$location,
        [Parameter(Mandatory=$true)]
        [PSCustomObject]$cloudMetadata
    )

    # Search the $armMetadata hash for the entry where the "name" parameter matches
    # $cloud and then find the login endpoint, from which we can discern the
    # appropriate "cloud based domain ending".
    $cloudBasedDomain = ($cloudMetadata.authentication.loginEndpoint -split "\.")[2]
    $configDpEndpoint = "https://${location}.dp.kubernetesconfiguration.azure.${cloudBasedDomain}"
    return $configDpEndpoint
}

function Get-ADResourceId {
    param (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]$cloudMetadata
    )

    # Search the $armMetadata hash for the entry where the "name" parameter matches
    # $cloud and then find the login endpoint, from which we can discern the
    # appropriate "cloud based domain ending".
    Write-Error "${cloudMetadata}"
    Write-Error "${cloudMetadata.authentication}"
    Write-Error "${cloudMetadata.authentication.audiences}"
    return $cloudMetadata.authentication.audiences[0]
}

Function Get-AzCloudMetadata {
    param (
        [string]$ApiVersion = "2022-09-01"
    )

    # This is a known endpoint.
    $MetadataEndpoint = "https://management.azure.com/metadata/endpoints?api-version=$ApiVersion"

    try {
        $Response = Invoke-RestMethod -Uri $MetadataEndpoint -Method Get -StatusCodeVariable StatusCode

        if ($StatusCode -ne 200) {
            $Msg = "ARM metadata endpoint '$MetadataEndpoint' returned status code $($StatusCode)."
            throw $Msg
        }
    }
    catch {
        $Msg = "Failed to request ARM metadata $MetadataEndpoint."
        Write-Error "$Msg Please ensure you have network connection. Error: $_"
    }

    # The current cloud in use is set by the user so query it and then we can use
    # it to index into the ARM Metadata.
    $context = $null
    try {
        $context = Get-AzContext
    }
    catch
    {
        throw "Failed to get the current Azure context. Error: $_"
    }
    $cloudName = $context.Environment.Name

    # Search the $armMetadata hash for the entry where the "name" parameter matches
    # $cloud and then find the login endpoint, from which we can discern the
    # appropriate "cloud based domain ending".
    $cloud = $Response | Where-Object { $_.name -eq $cloudName }
    return $cloud
}

# !!PDS: no dogfood so no need for this?
# function Get-ValuesFile {
#     # !!PDS: Review this syntax and used elsewhere?
#     $valuesFile = $env:HELMVALUESPATH
#     if ($null -ne $valuesFile -and (Test-Path $valuesFile)) {
#         Write-Warning "Values file detected. Reading additional helm parameters from same."
#         # Trimming required for Windows OS
#         if ($valuesFile.StartsWith("'") -or $valuesFile.StartsWith('"')) {
#             $valuesFile = $valuesFile.Substring(1)
#         }
#         if ($valuesFile.EndsWith("'") -or $valuesFile.EndsWith('"')) {
#             $valuesFile = $valuesFile.Substring(0, $valuesFile.Length - 1)
#         }
#         return $valuesFile
#     }
#     return $null
# }

function Get-HelmValues {
    param (
        [Parameter(Mandatory=$true)]
        $ConfigDpEndpoint,
        [string]$ReleaseTrainCustom,
        $RequestBody
    )

    # Setting uri
    $apiVersion = "2024-07-01-preview"
    $chartLocationUrlSegment = "azure-arc-k8sagents/GetHelmSettings?api-version=$apiVersion"
    $releaseTrain = if ($env:RELEASETRAIN) { $env:RELEASETRAIN } else { "stable" }
    $chartLocationUrl = "$ConfigDpEndpoint/$chartLocationUrlSegment"
    if ($ReleaseTrainCustom) {
        $releaseTrain = $ReleaseTrainCustom
    }
    $uriParameters = @{releaseTrain=$releaseTrain}
    $headers = @{}
    if ($env:AZURE_ACCESS_TOKEN) {
        $headers["Authorization"] = "Bearer $($env:AZURE_ACCESS_TOKEN)"
    }

    # Sending request with retries
    try {
        $r = Invoke-RestMethodWithUriParameters -Method 'post' -Uri $chartLocationUrl -Headers $headers -UriParameters $uriParameters -RequestBody $RequestBody -MaximumRetryCount 5 -RetryIntervalSec 3 -StatusCodeVariable statusCodeVariable

        # Response is a Hashtable of JSON values.
        if ($statusCode -eq 200 -and $r) {
            return $r
        }
        else {
            throw "No content was found in helm registry path response, StatusCode: ${statusCode}."
        }
    }
    catch {
        $errorMessage = "Error while fetching helm values from DP from JSON response: $_"
        Write-Error $errorMessage
        throw $errorMessage
    }
}

function Get-ChartPath {
    param (
        [string]$RegistryPath,
        [string]$KubeConfig,
        [string]$KubeContext,
        [string]$HelmClientLocation,
        [string]$ChartFolderName = 'AzureArcCharts',
        [string]$ChartName = 'azure-arc-k8sagents',
        [bool]$NewPath = $true
    )

    # Exporting Helm chart
    $ChartExportPath = Join-Path $env:USERPROFILE ('.azure', $ChartFolderName -join '\')
    try {
        if (Test-Path $ChartExportPath) {
            Remove-Item $ChartExportPath -Recurse -Force
        }
    }
    catch {
        Write-Warning "Unable to cleanup the $ChartFolderName already present on the machine. In case of failure, please cleanup the directory '$ChartExportPath' and try again."
    }

    Get-HelmChart -RegistryPath $RegistryPath -ChartExportPath $ChartExportPath -KubeConfig $KubeConfig -KubeContext $KubeContext -HelmClientLocation $HelmClientLocation -NewPath $NewPath -ChartName $ChartName

    # Returning helm chart path
    $HelmChartPath = Join-Path $ChartExportPath $ChartName
    if ($ChartFolderName -eq $consts.Pre_Onboarding_Helm_Charts_Folder_Name) {
        $ChartPath = $HelmChartPath
    }
    else {
        $ChartPath = if ($env:HELMCHART) { $env:HELMCHART } else { $HelmChartPath }
    }

    return $ChartPath
}

function Get-HelmChart {
    param (
        [string]$RegistryPath,
        [string]$ChartExportPath,
        [string]$KubeConfig,
        [string]$KubeContext,
        [string]$HelmClientLocation,
        [bool]$NewPath,
        [string]$ChartName = 'azure-arc-k8sagents',
        [int]$RetryCount = 5,
        [int]$RetryDelay = 3
    )

    $chartUrl = $RegistryPath.Split(':')[0]
    $chartVersion = $RegistryPath.Split(':')[1]

    if ($NewPath) {
        # Version check for stable release train (chart_version will be in X.Y.Z format as opposed to X.Y.Z-NONSTABLE)
        if (-not $chartVersion.Contains('-') -and ([version]$chartVersion -lt [version]"1.14.0")) {
            $errorSummary = "This CLI version does not support upgrading to Agents versions older than v1.14"
            # Assuming telemetry.set_exception and consts.Operation_Not_Supported_Fault_Type are handled elsewhere
            throw "Operation not supported on older Agents: $errorSummary"
        }

        # We do not use Split-Path here because it results in "\" characters in
        # the results.
        $basePath, $imageName = if ($chartUrl -match "(^.*?)/([^/]+$)") {$matches[1], $matches[2]}
        $chartUrl = "$basePath/v2/$imageName"
    }

    $cmdHelmChartPull = @($HelmClientLocation, "pull", "oci://$chartUrl", "--untar", "--untardir", $ChartExportPath, "--version", $chartVersion)
    if ($KubeConfig) {
        $cmdHelmChartPull += "--kubeconfig", $KubeConfig
    }
    if ($KubeContext) {
        $cmdHelmChartPull += "--kube-context", $KubeContext
    }

    Write-Debug "Pull helm chart: $cmdHelmChartPull[0] $cmdHelmChartPull[1..($cmdHelmChartPull.Count - 1)]"
    for ($i = 0; $i -lt $RetryCount; $i++) {
        try {
            & $cmdHelmChartPull[0] $cmdHelmChartPull[1..($cmdHelmChartPull.Count - 1)]
            break
        }
        catch {
            if ($i -eq $RetryCount - 1) {
                # Assuming telemetry.set_exception and consts.Pull_HelmChart_Fault_Type are handled elsewhere
                throw "Unable to pull $ChartName helm chart from the registry '$RegistryPath': $_"
            }
            Start-Sleep -Seconds $RetryDelay
        }
    }
}